# Scheduler Algorithm Simulator
운영체제 과목의 과제로 수행한 스케줄러 알고리즘 시뮬레이터.  
시뮬레이터는 워크로드에 대한 가정을 입력받아 FIFO, SJF, STCF, RR, MLFQ, Lottery 스케줄링한 결과를 출력한다.

## 사용법
### 컴파일
* 시뮬레이터 디렉토리로 이동한 후 make 명령어를 통해 컴파일을 수행한다. 수행 결과 아래의 출력을 보이며 컴파일된다.
```
Compilingi lab1 scheduler simulator lab1_sched.c ...
gcc -c -g -I/시뮬레이터 디렉토리 경로/include/ -o lab1_sched.o lab1_sched.c
Compilingi lab1 scheduler simulator lab1_sched_test.c ...
gcc -c -g -I/시뮬레이터 디렉토리 경로/include/ -o lab1_sched_test.o lab1_sched_test.c
gcc -o lab1_sched lab1_sched.o lab1_sched_test.o
```

* make clean 명령어를 통해 컴파일된 파일들을 깔끔하게 지울 수 있다. 수행 결과 아래의 출력을 보이며 컴파일된 파일들이 삭제된다.
```
Cleaning lab1 scheduler simulator  ...
rm -rf lab1_sched.o lab1_sched_test.o  lab1_sched
```

### 시뮬레이터 실행
1. 컴파일되어 생성된 lab1_sched 파일을 실행한다.
2. 아래와 같이 프로세스의 수와 워크로드 등의 정보를 입력한다.
```
Process의 수 : 5
RR에서 time slice(1은 기본적으로 출력) : 4
MLFQ에서 큐의 개수 : 3
A의 Arrival time과 Service time, Tickets (ex)0 3 30 : 0 3 30
B의 Arrival time과 Service time, Tickets (ex)0 3 30 : 2 6 30
C의 Arrival time과 Service time, Tickets (ex)0 3 30 : 4 4 30
D의 Arrival time과 Service time, Tickets (ex)0 3 30 : 6 5 30
E의 Arrival time과 Service time, Tickets (ex)0 3 30 : 8 2 30
```
3. 각 스케줄링 알고리즘마다의 결과가 출력된다.(예시 참조)

## 예시
### 워크로드
|프로세스|도착 시간|서비스 시간|티켓|
|:---:|:---:|:---:|:---:|
|A|0|3|30|
|B|2|6|30|
|C|4|4|30|
|D|6|5|30|
|E|8|2|30|

### 수행 결과
```
FIFO
A: |A|A|A| | | | | | | | | | | | | | | | | |
B: | | | |B|B|B|B|B|B| | | | | | | | | | | |
C: | | | | | | | | | |C|C|C|C| | | | | | | |
D: | | | | | | | | | | | | | |D|D|D|D|D| | |
E: | | | | | | | | | | | | | | | | | | |E|E|


SJF
A: |A|A|A| | | | | | | | | | | | | | | | | |
B: | | | |B|B|B|B|B|B| | | | | | | | | | | |
C: | | | | | | | | | | | |C|C|C|C| | | | | |
D: | | | | | | | | | | | | | | | |D|D|D|D|D|
E: | | | | | | | | | |E|E| | | | | | | | | |


SCTF
A: |A|A|A| | | | | | | | | | | | | | | | | |
B: | | | |B| | | | | | |B|B|B|B|B| | | | | |
C: | | | | |C|C|C|C| | | | | | | | | | | | |
D: | | | | | | | | | | | | | | | |D|D|D|D|D|
E: | | | | | | | | |E|E| | | | | | | | | | |


RR(1)
A: |A|A| |A| | | | | | | | | | | | | | | | |
B: | | |B| |B| |B| | |B| | | |B| | | |B| | |
C: | | | | | |C| | |C| | | |C| | | |C| | | |
D: | | | | | | | |D| | | |D| | | |D| | |D|D|
E: | | | | | | | | | | |E| | | |E| | | | | |


RR(4)
A: |A|A|A| | | | | | | | | | | | | | | | | |
B: | | | |B|B|B|B| | | | | | | | |B|B| | | |
C: | | | | | | | |C|C|C|C| | | | | | | | | |
D: | | | | | | | | | | | |D|D|D|D| | | | |D|
E: | | | | | | | | | | | | | | | | | |E|E| |


MLFQ(3, 1)
A: |A|A| |A| | | | | | | | | | | | | | | | |
B: | | |B| | |B| | | | | |B| | |B| | |B| |B|
C: | | | | |C| | |C| | | | |C| | |C| | | | |
D: | | | | | | |D| | |D| | | |D| | |D| |D| |
E: | | | | | | | | |E| |E| | | | | | | | | |


MLFQ(3, 2^i)
A: |A|A| |A| | | | | | | | | | | | | | | | |
B: | | |B| | |B|B| | | | | | | |B|B|B| | | |
C: | | | | |C| | | | |C|C| | | | | | |C| | |
D: | | | | | | | |D| | | |D|D| | | | | |D|D|
E: | | | | | | | | |E| | | | |E| | | | | | |


LOTTERY
A: |A|A| | | | | | |A| | | | | | | | | | | |
B: | | |B|B| |B| | | | |B| |B| | | | |B| | |
C: | | | | |C| | |C| | | | | |C| |C| | | | |
D: | | | | | | |D| | | | | | | |D| |D| |D|D|
E: | | | | | | | | | |E| |E| | | | | | | | |
```
(위의 결과는 콘솔의 결과를 그대로 복사한 것이며, Lottery의 경우 랜덤한 결과이기 때문에 매번 다른 결과를 보인다.)

## 스케줄링 알고리즘 설명
### 스케줄링 평가 항목
* 반환 시간(turnaround time)  
: 작업이 완료된 시각에서 작업이 시스템에 도착한 시각을 뺀 시간 (T<sub>turnaround</sub> = T<sub>completion</sub> - T<sub>arrival</sub>)

* 응답 시간(response time)  
: 작업이 도착할 때부터 처음 스케줄 될 때까지의 시간 (T<sub>response</sub> = T<sub>firstrun</sub> - T<sub>arrival</sub>)

### FIFO
선도착선처리(First Come First Served, FCFS)라고도 불리는 <b>선입선출(First In First Out, FIFO)</b>은 이름에서부터 알 수 있듯이 먼저 도착한 순서대로 작업을 처리하는 것을 말한다. 
예를 들어 10초짜리 3개의 작업 A, B, C가 0초에 거의 동시에 도착했지만, 간발의 차이로 A, B, C 순서로 도착했다고 가정했을 때의 결과는 다음과 같다.

![FIFO 예1](https://user-images.githubusercontent.com/77680436/106581156-e6131c80-6585-11eb-8efa-43ec9c696481.png)  
위의 예에서의 평균 반환 시간은 (10+20+30)/3 = 20초 이다.

FIFO의 경우 단순하고 구현하기 쉽다는 장점을 가지고 있지만 짧은 시간 동안 자원을 사용할 프로세스들이 자원을 오래 사용하는 프로세스의 종료를 기다리는 현상인 convoy effect가 발생할 수 
있다는 단점이 있다. 아래는 convoy effect의 예이다.

![FIFO 예2](https://user-images.githubusercontent.com/77680436/106582813-be24b880-6587-11eb-99a5-f82a5569f6c9.png)  
이 경우 평균 반환 시간은 (100+110+120)/3 = 110초 이다. 이는 다음에 설명할 SJF보다 안 좋은 것을 볼 수 있다.

### SJF
**최단 작업 우선(Shortest Job First, SJF)** 역시 이름에서 알 수 있듯이 가장 짧은 실행 시간을 가진 작업부터 실행시키는 것이다. FIFO의 convoy effect 예에 대한 가정을 SJF에서 실행했을 
경우는 다음과 같다.

![SJF 예1](https://user-images.githubusercontent.com/77680436/106584115-2aec8280-6589-11eb-9541-e40b0bf7a52a.png)  
위의 예에서의 평균 반환 시간은 (10+20+120)/3 = 50초 이다. FIFO에서의 평균 반환 시간보다 훨씬 빠른 것을 볼 수 있다.

SJF의 경우 모든 작업이 동시에 도착한다면 반환 시간 측면에서 최적의 스케줄링 알고리즘이지만, 모든 작업이 동시에 도착한다는 가정은 비현실적이다. 만약 A는 0초, B, C는 1초에 도착한다고 하였을 때 0초에서 
스케줄러는 B, C가 도착할 것을 모르기 때문에 A를 처리할 것이다. 이 경우의 그림은 다음과 같다.

![SJF 예2](https://user-images.githubusercontent.com/77680436/106585148-5de34600-658a-11eb-9457-6993434ec804.png)  
위의 예에서 평균 반환 시간은 (100+(110-1)+(120-1))/3 = 109.33초 이다. 이 경우 FIFO에서의 문제와 크게 다를 바가 없다.

### STCF  
여태까지의 알고리즘들은 각 작업이 끝날 때까지 계속 실행되었다. 이를 비선점(non-preemptive) 스케줄러라고 한다. 반면에 다른 프로세스를 실행하기 위해 필요시 현재 프로세스의 실행을 
중단하기도 하는데, 이를 선점(preemptive) 스케줄러라고 한다.  

**최소 잔여시간 우선(Shortest Time-to-Completion First, STCF)** 또는 선점형 최단 작업 우선(Preemptive SJF, PSJF)은 SJF에 선점 기능을 추가한 것을 말한다. 즉, 남아있는 작업과 새로운 
작업의 잔여 실행 시간 중 가장 짧은 시간을 가진 작업부터 스케줄하는 것이다. SJF에서의 convoy effect 예를 STCF에서 실행하면 다음과 같다.

![STCF 예](https://user-images.githubusercontent.com/77680436/106593122-c08d0f80-6593-11eb-8dc2-c996f9ad0086.png)  
위의 예에서의 평균 반환 시간은 ((120-0)+(11-1)+(21-1))/3 = 50초 이다. 이는 SJF에서 예제1과 같이 최적이다. 이처럼 STCF는 모두 동시에 도착한다는 가정에서 반환 시간 측면으로 최적의 결과를 낸다는 SJF의 
제한사항을 해결해준다.

### RR
여태까지의 스케줄링들은 모두 반환 시간을 집중적으로 개선해나갔다. 하지만 점차 사용자와 시스템간의 원할한 상호작용을 중요하게 생각하면서 응답 시간은 중요한 평가 지표가 되었다.

반환시간에서 최적을 보장하는 STCF의 예를 응답 시간 측면에서 살펴보면, C는 10초의 응답 시간을 갖는다. 즉, C 작업을 요청한 사용자는 시스템으로부터 응답을 받기 위해 10초를 기다려야 
한다는 소리이다. 이는 바로바로 작업의 응답을 받는 현대 사회에서는 상상하기 힘든 일이다.  

<b>라운드 로빈(Round-Robin, RR)</b>은 이러한 응답 시간 문제를 해결하기 위한 스케줄링이다. RR은 일정 시간 동안 작업을 실행한 후 큐의 다음 작업으로 전환하는 식으로 작업이 완료될 
때까지 진행한다. 여기서 작업이 실행되는 일정 시간을 타임 슬라이스(time slice) 또는 스케줄링 퀀텀(scheduling quantum)이라고 한다. 이제 RR의 예를 살펴보면 다음과 같다.(A, B, C 각 9초짜리의 작업이 0초에 동시 도착, 타임 슬라이스 = 1초)

![RR 예](https://user-images.githubusercontent.com/77680436/106598608-524c4b00-659b-11eb-84d0-f8c59d93508d.png)  
이 경우 평균 응답 시간은 (0+1+2)/3 = 1초이다. 이는 같은 조건으로 STCF를 수행하였을 때 (0+9+18)/3 = 9초에 비하면 매우 빠른 응답 시간을 갖는 것을 볼 수 있다. 하지만 평균 반환 시간을 
고려해보면 RR의 경우 (25+26+27)/3 = 26초이지만, STCF는 (9+18+27)/3 = 18초이다. 이처럼 RR은 응답 시간 측면에서는 최적화 되어 있지만 반환 시간 측면에서는 성능이 나쁘다.

### MLFQ
<b>멀티 레벨 피드백 큐(Multi-level Feedback Queue, MLFQ)</b>는 대화형 프로세스는 더 높은 우선순위로, CPU를 집중적으로 사용하는 프로세스는 더 낮은 우선순위로 실행하면서 
SJF나 STCF와 같은 알고리즘의 반환 시간적 이점과 RR의 응답 시간적 이점을 동시에 취하는 스케줄링이다. 
MLFQ는 우선순위가 배정된 여러 개의 큐로 구성되어 있으며, 다음과 같이 동작한다.

1. 각 작업의 우선순위가 다를 경우, 높은 우선 순위의 작업이 실행된다.
2. 각 작업이 같은 우선순위를 가질 경우, 각 작업은 RR 방식으로 실행된다.
3. 시스템에 작업이 들어올 때, 해당 작업은 가장 높은 우선순위를 갖는다.
4. 각 작업은 배정받은 시간을 소진하면, 우선순위는 감소된다.
5. 일정 주기가 지난 후, 모든 작업을 최상위 큐로 이동시킨다.

SJF나 SCTF는 알고리즘을 수행하기 위해서 작업의 실행 시간 정보를 필요로 한다. 하지만 실제의 경우에는 실행 시간을 미리 알 수 없다. 그렇다면 MLFQ에서는 어떻게 현실적으로 
SJF나 STCF의 장점을 취할 수 있을까. 이는 MLFQ가 과거의 실행 경험을 기반으로 미래를 예측하는 방법을 사용하기 때문이다. 이름에 Feedback이 붙은 것도 이 때문인데, MLFQ가 어떻게 SJF에 근사하게 동작하는지 
보여주는 예는 다음과 같다.  
(A = 긴 시간 실행되는 CPU 위주 작업, B = 짧은 시간(2초) 실행되는 대화형 작업 / 작업에 배정된 시간 = 1초 / A가 실행 중에 실행 시간이 짧은 B가 시스템에 들어온 상황)

![MLFQ 예](https://user-images.githubusercontent.com/77680436/106615577-ecb68980-65af-11eb-8dbe-7f0b02b8a025.png)  
위의 예처럼, 작업의 시간이 짧은 B의 경우는 마지막 우선순위의 큐에 도착하기도 전에 실행이 완료되는 것을 볼 수 있다. 이처럼 MLFQ는 일단 짧은 작업이라고 가정하여 높은 우선순위를 부여하고 
해당 작업의 수행 시간에 따라 스스로 자신을 증명하는 방식을 통해 STCF의 장점을 취한다.

### Lottery
<b>추첨 스케줄링(Lottery scheduling)</b>은 위의 스케줄링들과는 다르게 반환 시간이나 응답 시간보다는 공정성에 초점을 맞춘 방법이다. 공정성이란 각 작업들이 일정한 비율로 실행되는 것이 얼마나 보장되는가를 말한다. 즉, Lottery scheduling은 각 작업에 일정 비율의 CPU 배정을 보장하는 것을 목적으로 한다.

Lottery scheduling은 추첨권 또는 티켓이라는 개념을 사용하는데, 프로세스가 소유한 티켓의 수가 전체 티켓에서 
차지하는 비율만큼 CPU 할당을 보장받는 것을 목표로한다. 예를 들어서 A는 60장의 티켓, B는 40장의 티켓을 가지고 있다고 하면 Lottery scheduling의 목표는 A 작업이 60%, B 작업이 40% 비율로 실행되는 것이다. 
동작 과정은 실생활의 추첨 행사를 생각하면 이해할 수 있을 정도로 간단하다. 위의 예에서 전체 티켓은 100장이다. 여기서 스케줄러는 랜덤으로 0부터 99까지의 숫자를 뽑는다. 추첨 결과 0-59 사이의 
숫자가 당첨될 경우 A 작업을, 60-99 사이의 숫자가 당첨되면 B 작업을 실행한다. 이러한 과정을 작업이 끝날 때까지 반복하여 수행하는 것이 Lottery scheduling이다. 물론 당첨이 랜덤이기 때문에, 
정확히 해당 비율로 실행이 되지 않을 수 있다. 주사위를 6번 던진다고 1부터 6이 정확히 1번씩 나오지 않는 것과 같다. 하지만 큰 수의 법칙에 의해서 두 작업이 긴 시간 실행될수록 목표했던 
비율을 달성할 확률이 높아진다.

![Lottery 예](https://user-images.githubusercontent.com/77680436/106644177-1b435d00-65ce-11eb-8d75-31e91e096243.png)  
위의 예에서 A는 8번, B는 4번 실행되었다. 즉 67%, 33% 비율로 실행되었으며, 티켓 비율과 유사하다.

## 참고사항
* 본 시뮬레이터는 MLFQ의 4번 규칙을 완화하여 모든 큐에 작업이 자신밖에 없다면 배정받은 시간을 소진하더라도 우선순위가 감소되지 않도록 하였다.
* 본 시뮬레이터는 MLFQ의 5번 규칙을 구현하지 않았다.
* MLFQ(큐의 수, 2^i)에서 2^i는 큐 별 타임 슬라이스를 의미한다. 즉 우선순위가 낮은 큐는 더 긴 시간을 배정해준다는 것으로, 우선순위가 하나씩 내려갈 때마다 배정시간은 두 배가 된다.  

예시(우선순위는 큐0이 제일 높다)
|큐|배정시간|
|:---:|:---:|
|큐0|1|
|큐1|2|
|큐2|4|
